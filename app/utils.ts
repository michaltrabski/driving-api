const fs = require("fs-extra");

const excel4 = require("../sourceData/questionsFromExcel052020.json");
const excel5 = require("../sourceData/questionsFromExcel22022022.json");
const excel6 = require("../sourceData/questionsFromExcel27062023.json");

const expl360 = require("../sourceData/wyjasnienia360_08122023.json");
const oldMasterQuestions = require("../sourceData/masterQuestions.json");

import { CHAT_GPT_ANSWERS } from "./askChatGpt";
import {
  CategoriesObj,
  NormalizedQuestionE4,
  NormalizedQuestionE5,
  NormalizedQuestionE6,
  QuestionBig,
  QuestionSmall,
} from "./types";

const TP = "Treść pytania";
const NR = "Numer pytania";

export const getQuestionsBig = (limit: number): QuestionBig[] => {
  const { ids, e4, e5, e6 } = getQuestionsIds();

  console.log({ ids: ids.length, e4: e4.length, e5: e5.length, e6: e6.length });

  const questions = ids.slice(0, limit).map((id) => {
    const q4 = e4.find((q) => q.id === id);
    const q5 = e5.find((q) => q.id === id);
    const q6 = e6.find((q) => q.id === id);
    const old = oldMasterQuestions.allQuestions.find((q: any) => q.id === id);

    const questionBig: QuestionBig = {
      slug: "error",
      id: "error",
      isActive: false,
      text: "error",
      textEn: "error",
      textDe: "error",
      a: "error",
      b: "error",
      c: "error",
      r: "error",
      media: "error",
      categories: ["error"],
      score: -1,
      questionSource: "error",
      relationToSafety: "error",
      whatWeWantToAskFor: "error",
      explanationTesty360: "error",
      explanationGpt3: {
        shortExplanation: "", // it may be empty string if there is no explanation generated by GPT3
        longExplanation: "", // it may be empty string if there is no explanation generated by GPT3
        textSeo: "", // it may be empty string if there is no explanation generated by GPT3
      },
      deprecated_expl: "error",
      deprecated_lowNameOld: "error",
      deprecated_lowName: "error",
      deprecated_lowNames: "error",
      deprecated_low: "error",
    };

    if (q6) {
      questionBig.slug = createSlugWithId(q6.text, q6.id);
      questionBig.id = q6.id;
      questionBig.isActive = true;
      questionBig.text = q6.text;
      questionBig.textEn = q6.textEn;
      questionBig.textDe = q6.textDe;
      questionBig.a = q6.a;
      questionBig.b = q6.b;
      questionBig.c = q6.c;
      questionBig.r = q6.r;
      questionBig.media = q6.media;
      questionBig.categories = q6.categories;
      questionBig.score = q4?.score || 3; // there is no score in excel6
      questionBig.questionSource = q6.questionSource;
      questionBig.relationToSafety = q6.relationToSafety;
      questionBig.whatWeWantToAskFor = q5?.whatWeWantToAskFor || "";
      questionBig.explanationTesty360 = findExplanationTesty360ByText(q6.text);
      questionBig.deprecated_expl = old?.expl || "";
      questionBig.deprecated_lowNameOld = old?.lowNameOld || "";
      questionBig.deprecated_lowName = old?.lowName || "";
      questionBig.deprecated_lowNames = old?.lowNames || "";
      questionBig.deprecated_low = old?.low || "";

      const explanationGpt3 = fs.readJsonSync(`${CHAT_GPT_ANSWERS}/${q6.id}.json`, {
        throws: false,
      });

      if (explanationGpt3 && explanationGpt3.answer) {
        const ans = explanationGpt3.answer;
        const shortExplanation = ans.match(/shortExplanation:([\s\S]*?)longExplanation:/gi);
        const longExplanation = ans.match(/longExplanation:([\s\S]*?)textSeo:/gi);
        const textSeo = ans.match(/textSeo:([\s\S]*?)$/gi);

        questionBig.explanationGpt3 = {
          shortExplanation: shortExplanation
            ? shortExplanation[0]
                .replace("shortExplanation:", "")
                .replace(/\n/g, "")
                .replace("longExplanation:", "")
                .trim()
            : "",
          longExplanation: longExplanation
            ? longExplanation[0].replace("longExplanation:", "").replace(/\n/g, "").replace("textSeo:", "").trim()
            : "",
          textSeo: textSeo ? textSeo[0].replace("textSeo:", "").replace(/\n/g, "").trim() : "",
        };
      }

      return questionBig;
    }

    if (q5) {
      questionBig.slug = createSlugWithId(q5.text, q5.id);
      questionBig.id = q5.id;
      questionBig.isActive = false;
      questionBig.text = q5.text;
      questionBig.textEn = q5.textEn;
      questionBig.textDe = q5.textDe;
      questionBig.a = q5.a;
      questionBig.b = q5.b;
      questionBig.c = q5.c;
      questionBig.r = q5.r;
      questionBig.media = q5.media;
      questionBig.categories = q5.categories;
      questionBig.score = q5.score;
      questionBig.questionSource = q5.questionSource;
      questionBig.relationToSafety = q5.relationToSafety;
      questionBig.whatWeWantToAskFor = q5.whatWeWantToAskFor;
      questionBig.explanationTesty360 = findExplanationTesty360ByText(q5.text);
      questionBig.deprecated_expl = old?.expl || "";
      questionBig.deprecated_lowNameOld = old?.lowNameOld || "";
      questionBig.deprecated_lowName = old?.lowName || "";
      questionBig.deprecated_lowNames = old?.lowNames || "";
      questionBig.deprecated_low = old?.low || "";

      return questionBig;
    }

    if (q4) {
      questionBig.slug = createSlugWithId(q4.text, q4.id);
      questionBig.id = q4.id;
      questionBig.isActive = false;
      questionBig.text = q4.text;
      questionBig.textEn = q4.textEn;
      questionBig.textDe = q4.textDe;
      questionBig.a = q4.a;
      questionBig.b = q4.b;
      questionBig.c = q4.c;
      questionBig.r = q4.r;
      questionBig.media = q4.media;
      questionBig.categories = q4.categories;
      questionBig.score = q4.score;
      questionBig.questionSource = "";
      questionBig.relationToSafety = "";
      questionBig.explanationTesty360 = findExplanationTesty360ByText(q4.text);
      questionBig.deprecated_expl = old?.expl || "";
      questionBig.deprecated_lowNameOld = old?.lowNameOld || "";
      questionBig.deprecated_lowName = old?.lowName || "";
      questionBig.deprecated_lowNames = old?.lowNames || "";
      questionBig.deprecated_low = old?.low || "";

      return questionBig;
    }

    return questionBig;
  });

  return questions;
};

export const getQuestionsSmall = (questionsBig: QuestionBig[]): QuestionSmall[] => {
  const questionsSmall = questionsBig.map((q) => {
    const questionSmall: QuestionSmall = {
      slug: q.slug,
      isActive: q.isActive,
      id: q.id,
      text: q.text,
      a: q.a,
      b: q.b,
      c: q.c,
      r: q.r,
      media: q.media,
      categories: q.categories,
      score: q.score,
    };

    return questionSmall;
  });

  return questionsSmall;
};

export const getCategories = (questions: QuestionBig[]) => {
  const categories = Array.from(new Set(questions.flatMap((q) => q.categories)));
  const categoriesOrdered = categories.sort((a, b) => a.localeCompare(b));

  return categoriesOrdered;
};

export const getCategoriesObj = (questions: QuestionBig[]): CategoriesObj => {
  const categories = Array.from(new Set(questions.flatMap((q) => q.categories)));
  const categoriesOrdered = categories.sort((a, b) => a.localeCompare(b));

  const categoriesWithCount = categoriesOrdered.reduce((acc, category) => {
    const count = questions.filter((q) => q.categories.includes(category)).length;

    acc[category] = count;

    return acc;
  }, {} as { [key: string]: number });

  const categoriesObj: CategoriesObj = {
    categoriesCount: categoriesOrdered.length,
    categories: categoriesOrdered,
    categoriesWithCount,
  };

  return categoriesObj;
};

export const getQuestionsIds = () => {
  const e4 = normalizeExcel4Questions();
  const e5 = normalizeExcel5Questions();
  const e6 = normalizeExcel6Questions();

  const ids = Array.from(new Set([...e6.map((q) => q.id), ...e5.map((q) => q.id), ...e4.map((q) => q.id)])).sort(
    () => Math.random() - 0.5
  );

  return { ids, e4, e5, e6 };
};

export const normalizeExcel4Questions = (): NormalizedQuestionE4[] => {
  const excel4NormalizedQuestions = excel4[TP].map(
    (q: {
      "Numer pytania": string;
      Pytanie: string;
      "Odpowiedź A": string;
      "Odpowiedź B": string;
      "Odpowiedź C": string;
      "Pytanie ENG": string;
      "Odpowiedź ENG A": string;
      "Odpowiedź ENG B": string;
      "Odpowiedź ENG C": string;
      "Pytanie DE": string;
      "Odpowiedź DE A": string;
      "Odpowiedź DE B": string;
      "Odpowiedź DE C": string;
      "Poprawna odp": string;
      Media: string;
      "Zakres struktury": string;
      "Liczba punktów": string;
      Kategorie: string;
      "Nazwa bloku": string;
      "Nazwa media tłumaczenie migowe (PJM) treść pyt": string;
      "Nazwa media tłumaczenie migowe (PJM) treść odp A": string;
      "Nazwa media tłumaczenie migowe (PJM) treść odp B": string;
      "Nazwa media tłumaczenie migowe (PJM) treść odp C": string;
    }) => {
      const normalizedQuestionE4: NormalizedQuestionE4 = {
        id: `id${q[NR]}`,
        text: q["Pytanie"],
        textEn: q["Pytanie ENG"],
        textDe: q["Pytanie DE"],
        a: q["Odpowiedź A"],
        b: q["Odpowiedź B"],
        c: q["Odpowiedź C"],
        r: normalizeRightAnswer(q["Poprawna odp"]),
        media: normalizeMediaName(q["Media"]),
        categories: q["Kategorie"].toLowerCase().split(","),
        score: +q["Liczba punktów"],
      };

      return normalizedQuestionE4;
    }
  );

  return excel4NormalizedQuestions;
};

export const normalizeExcel5Questions = (): NormalizedQuestionE5[] => {
  const excel5NormalizedQuestions = excel5[TP].map(
    (q: {
      "Nazwa pytania": string;
      "Numer pytania": string;
      Pytanie: string;
      "Odpowiedź A": string;
      "Odpowiedź B": string;
      "Odpowiedź C": string;
      "Pytanie ENG": string;
      "Odpowiedź ENG A": string;
      "Odpowiedź ENG B": string;
      "Odpowiedź ENG C": string;
      "Pytanie DE": string;
      "Odpowiedź DE A": string;
      "Odpowiedź DE B": string;
      "Odpowiedź DE C": string;
      "Poprawna odp": string;
      Media: string;
      "Zakres struktury": string;
      "Liczba punktów": string;
      Kategorie: string;
      "Nazwa bloku": string;
      "Źródło pytania": string;
      "O co chcemy zapytać": string;
      "Jaki ma związek z bezpieczeństwem": string;
      Status: string;
      Podmiot: string;
      "Nazwa media tłumaczenie migowe (PJM) treść pyt": string;
      "Nazwa media tłumaczenie migowe (PJM) treść odp A": string;
      "Nazwa media tłumaczenie migowe (PJM) treść odp B": string;
      "Nazwa media tłumaczenie migowe (PJM) treść odp C": string;
      "Nazwa media tłumaczenie migowe (SJM) treść pyt": string;
      "Nazwa media tłumaczenie migowe (SJM) treść odp A": string;
      "Nazwa media tłumaczenie migowe (SJM) treść odp B": string;
      "Nazwa media tłumaczenie migowe (SJM) treść odp C": string;
    }) => {
      const normalizedQuestionE4: NormalizedQuestionE5 = {
        id: `id${q[NR]}`,
        text: q["Pytanie"],
        textEn: q["Pytanie ENG"],
        textDe: q["Pytanie DE"],
        a: q["Odpowiedź A"],
        b: q["Odpowiedź B"],
        c: q["Odpowiedź C"],
        r: normalizeRightAnswer(q["Poprawna odp"]),
        media: normalizeMediaName(q["Media"]),
        categories: q["Kategorie"].toLowerCase().split(","),
        score: +q["Liczba punktów"],
        whatWeWantToAskFor: q["O co chcemy zapytać"],
        relationToSafety: q["Jaki ma związek z bezpieczeństwem"],
        questionSource: q["Źródło pytania"],
      };

      return normalizedQuestionE4;
    }
  );

  return excel5NormalizedQuestions;
};

export const normalizeExcel6Questions = (): NormalizedQuestionE6[] => {
  const excel6NormalizedQuestions = excel6["Arkusz1"].map(
    (q: {
      "Lp.": string;
      "Numer pytania": string;
      Pytanie: string;
      "Odpowiedź A": string;
      "Odpowiedź B": string;
      "Odpowiedź C": string;
      "Pytanie ENG": string;
      "Odpowiedź ENG A": string;
      "Odpowiedź ENG B": string;
      "Odpowiedź ENG C": string;
      "Pytanie DE": string;
      "Odpowiedź DE A": string;
      "Odpowiedź DE B": string;
      "Odpowiedź DE C": string;
      "Poprawna odp": string;
      Media: string;
      Kategorie: string;
      "Źródło pytania": string;
      "Jaki ma związek z bezpieczeństwem": string;
      "Nazwa media tłumaczenie migowe (PJM) treść pyt": string;
      "Nazwa media tłumaczenie migowe (PJM) treść odp A": string;
      "Nazwa media tłumaczenie migowe (PJM) treść odp B": string;
      "Nazwa media tłumaczenie migowe (PJM) treść odp C": string;
    }) => {
      return {
        id: `id${q[NR]}`,
        text: q["Pytanie"],
        textEn: q["Pytanie ENG"],
        textDe: q["Pytanie DE"],
        a: q["Odpowiedź A"],
        b: q["Odpowiedź B"],
        c: q["Odpowiedź C"],
        r: normalizeRightAnswer(q["Poprawna odp"]),
        media: normalizeMediaName(q["Media"]),
        categories: q["Kategorie"].toLowerCase().split(","),
        questionSource: q["Źródło pytania"],
        relationToSafety: q["Jaki ma związek z bezpieczeństwem"],
      };
    }
  );

  return excel6NormalizedQuestions;
};

const normalizeMediaName = (fileName: string) => {
  if (fileName.toLowerCase().endsWith(".wmv")) {
    return fileName.replace(".wmv", ".mp4").replace(".WMV", ".mp4");
  }
  if (fileName.toLowerCase().endsWith(".jpg")) {
    return fileName.replace(".jpg", ".png").replace(".JPG", ".png");
  }
  if (fileName === "") {
    return fileName;
  }

  console.log("CHECK THIS MEDIA FILE NAME", fileName);
  return fileName;
};

const normalizeRightAnswer = (r: string) => {
  if (r.toLowerCase() === "tak" || r.toLowerCase() === "t") {
    return "t";
  }

  if (r.toLowerCase() === "nie" || r.toLowerCase() === "n") {
    return "n";
  }

  if (r.toLowerCase() === "a") {
    return "a";
  }
  if (r.toLowerCase() === "b") {
    return "b";
  }
  if (r.toLowerCase() === "c") {
    return "c";
  }

  console.log("CHECK RIGHT ANSWER", r);
  return r;
};

const findExplanationTesty360ByText = (text: string) => {
  const expl360Arr: {
    idFromTesty360: string;
    text: string;
    topic: string;
    explanationTesty360: string;
  }[] = Object.values(expl360);

  const expl = expl360Arr.find((expl) => expl.text === text);

  if (!expl) {
    return "";
  }

  return expl.explanationTesty360;
};

export function textToSlug160(text: string) {
  text = text.toLowerCase().trim();

  const from = ["ę", "ó", "ą", "ś", "ł", "ż", "ź", "ć", "ń"];
  const to__ = ["e", "o", "a", "s", "l", "z", "z", "c", "n"];

  for (let i = 0; i < from.length; i++) {
    text = text.replace(new RegExp(from[i], "g"), to__[i]);
  }

  text = text
    .replace(/[^a-z0-9 -]/g, "")
    .replace(/\s+/g, "-")
    .replace(/-+/g, "-");

  return text.slice(0, 160);
}

export const createSlugWithId = (text: string, id: string) => {
  return `${textToSlug160(text)}-id-pytania-${id.replace("id", "")}`;
};

export function getPhpCode(fileName: string) {
  return `<?php
              header('Content-Type: application/json');
              header('Access-Control-Allow-Origin: *');
              header('Access-Control-Allow-Methods: GET, POST');
              header('Access-Control-Allow-Headers: Content-Type');

              $jsonData = file_get_contents('${fileName}.json');

              echo $jsonData;`;
}

// // export function getHtmlCode(objAsString: string) {
// //   return objAsString;
// // }

// // export function textToSlug(text: string, id: string) {
// //   let slug = `${text.slice(0, 160)}-id-pytania-${id.replace("id", "")}`;

// //   slug = slug.replace(/^\s+|\s+$/g, ""); // trim
// //   slug = slug.toLowerCase();

// //   // remove accents, swap ñ for n, etc
// //   var from = "ęóąśłżźćńàáäâèéëêìíïîòóöôùúüûñç·/_,:;";
// //   var to__ = "eoaslzzcnaaaaeeeeiiiioooouuuunc------";
// //   for (var i = 0, l = from.length; i < l; i++) {
// //     slug = slug.replace(new RegExp(from.charAt(i), "g"), to__.charAt(i));
// //   }

// //   slug = slug
// //     .replace(/[^a-z0-9 -]/g, "") // remove invalid chars
// //     .replace(/\s+/g, "-") // collapse whitespace and replace by -
// //     .replace(/-+/g, "-"); // collapse dashes

// //   return slug;
// // }

// // export function convertMediaNameToPngOrMp4(mediaName: string) {
// //   if (mediaName.endsWith(".jpg")) {
// //     return mediaName.replace(".jpg", ".png");
// //   }
// //   if (mediaName.endsWith(".JPG")) {
// //     return mediaName.replace(".JPG", ".png");
// //   }
// //   if (mediaName.endsWith(".jpeg")) {
// //     return mediaName.replace(".jpeg", ".png");
// //   }
// //   if (mediaName.endsWith(".JPEG")) {
// //     return mediaName.replace(".JPEG", ".png");
// //   }
// //   if (mediaName.endsWith(".wmv")) {
// //     return mediaName.replace(".wmv", ".mp4");
// //   }

// //   return mediaName;
// // }

// // export const getEnv = (variableName: string) => {
// //   if (variableName === undefined) {
// //     console.log(`ERROR: ENV VARIABLE: ${variableName} is not set in .env file`);
// //     throw new Error(`ERROR: ENV VARIABLE: ${variableName} is not set in .env file`);
// //   }

// //   if (process.env[variableName] === undefined) {
// //     console.log(`ERROR: ENV VARIABLE: ${variableName} is not set in .env file`);
// //     throw new Error(`ERROR: ENV VARIABLE: ${variableName} is not set in .env file`);
// //   }

// //   return process.env[variableName] ?? string;
// // };

// // export function isVideo(fileName: string) {
// //   const videoExtensions = [".wmv", ".mp4", ".WMV", ".MP4"];

// //   return videoExtensions.some((ext) => fileName.endsWith(ext));
// // }
// // export function mediaNameWithoutExtention(mediaName: string) {
// //   return mediaName.split(".").slice(0, -1).join(".");
// // }

// // export function normalizeABCTAKNIE(answer: string): RightAnswer | never {
// //   if (answer.toLowerCase() === "tak" || answer.toLowerCase() === "t") {
// //     return "t";
// //   }
// //   if (answer.toLowerCase() === "nie" || answer.toLowerCase() === "n") {
// //     return "n";
// //   }
// //   if (answer.toLowerCase() === "a") {
// //     return "a";
// //   }
// //   if (answer.toLowerCase() === "b") {
// //     return "b";
// //   }
// //   if (answer.toLowerCase() === "c") {
// //     return "c";
// //   }

// //   throw new Error(`ERROR: normalizeABCTAKNIE: answer: ${answer} is not valid`);
// // }
export function reverseNormalizeABCTAKNIE(answer: string): string | never {
  if (answer === "t") {
    return "tak";
  }
  if (answer === "n") {
    return "nie";
  }
  if (answer === "a") {
    return "a";
  }
  if (answer === "b") {
    return "b";
  }
  if (answer === "c") {
    return "c";
  }

  throw new Error(`ERROR: reverseNormalizeABCTAKNIE: answer: ${answer} is not valid`);
}

// // export function normalizeMediaName(mediaName: string) {
// //   if (mediaName === "") {
// //     return string;
// //   }

// //   if (mediaName.endsWith(".jpg") || mediaName.endsWith(".JPG") || mediaName.endsWith(".jpeg") || mediaName.endsWith(".JPEG")) {
// //     // replace last occurence of .jpg
// //     return mediaName.replace(/\.jpg(?!.*\.jpg)/, ".png");
// //   }

// //   if (mediaName.endsWith(".wmv") || mediaName.endsWith(".WMV")) {
// //     // replace last occurence of .wmv
// //     return mediaName.replace(/\.wmv(?!.*\.wmv)/, ".mp4");
// //   }

// //   throw new Error(`ERROR: normalizeMediaName: mediaName: ${mediaName} is not valid`);
// // }

export const isAnswerYesNo = (r: string) => r === "t" || r === "n";
export const IsAnswerABC = (r: string) => r === "a" || r === "b" || r === "c";
